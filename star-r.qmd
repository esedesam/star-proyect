---
title: "Proyecto STAR"
subtitle: "Inferencia Causal"
description: "Máster en Ciencia de Datos (UV)"
author: "Adrián Lara, Jesús Martínez, Miguel Muñoz, Samuel Ortega & Pablo Vicente"
date: last-modified
date-format: "DD-MM-YYYY"
title-block-banner: "#B0C8D6"
format: 
  html:
    embed-resources: true
    smooth-scroll: true
    toc: true
    toc_float: yes
    theme: cosmo
    fontcolor: black
editor: source
execute: 
  echo: false
  warning: false
  error: false
  message: false
  include: true
lang: es
css: utilities/qmdStyle.css
---

# Proyecto *STAR*

```{r setup}
#| include: false

# Cargar pacman
if (!require("pacman", quietly = TRUE)) {
  install.packages("pacman")
  library(pacman)
}

# Cargar los paquetes necesarios
p_load(AER, ggplot2, ggthemes, dplyr, tidyr, knitr, fastDummies, MatchIt)

# Ajustes adicionales
theme_set(
  theme_minimal() +
    theme(
      panel.border = element_rect(color = "black", fill = NA),
      axis.ticks = element_line(color = "black")))

defaultFillColor <- "steelblue"
update_geom_defaults("bar", aes(fill = defaultFillColor))
update_geom_defaults("boxplot", aes(fill = defaultFillColor))

# Definición de funciones
plotCombinedFeature <- function(starDf, featureId, featureLabel = NA, isNumeric = TRUE, removeNa = FALSE) {
  if (is.na(featureLabel)) {
    featureLabel <- featureId
  }
  plotDf <- pivot_longer(
    starDf,
    cols = grep(paste0("^", featureId, ".{1}$"), colnames(starDf), value = TRUE),
    names_to = "grade",
    values_to = "value")
  
  featureLevels <- paste0(featureId, c("k", "1", "2", "3"))
  plotDf$grade <- factor(
    plotDf$grade,
    levels = featureLevels,
    labels = c("Kindergarden", "Primero", "Segundo", "Tercero"),
    ordered = TRUE)
  
  if (removeNa) {
    plotDf <- na.omit(plotDf[, c("grade", "value")])
  }
  
  if (isNumeric) {
    ggplot(plotDf, aes(x = grade, y = value)) +
      geom_boxplot() +
      labs(x = "Curso", y = featureLabel)
  } else {
    ggplot(plotDf, aes(x = value, fill = grade)) +
      geom_bar(position = "dodge") +
      labs(x = featureLabel, y = "Frecuencia acumulada", fill = "Curso")
  }
}

# Numerización automática en tablas y figuras

outputFormat   = opts_knit$get("rmarkdown.pandoc.to")

capTabNo = 2; capFigNo = 1;

capTab = function(x){
  if(outputFormat == 'html'){
    x = paste0("<strong>Table ", capTabNo,". </strong> ",x)
    capTabNo <<- capTabNo + 1
  }; x
}

capFig = function(x, y){
  if(outputFormat == 'html'){
    x = paste0("<strong>Figura ", capFigNo, ".</strong> ", x, " \\label{fig:", y, "}")
    capFigNo <<- capFigNo + 1
  }; x
}
```

## Introducción

El proyecto *STAR* (*Student-Teacher Achievement Ratio*) es un estudio sobre el tamaño de las clases llevado a cabo en Tennessee en tres fases, diseñado para determinar el efecto del **tamaño reducido de las clases** en los primeros grados sobre el **rendimiento académico** a corto y largo plazo de los alumnos. Se inspiró en un estudio prometedor realizado en Indiana sobre los beneficios de las clases pequeñas, pero también consideró los costos adicionales de más aulas y profesores. La legislatura de Tennessee autorizó este estudio de **cuatro años** para obtener datos sobre la eficacia de las clases reducidas.

Se compararon los resultados de alumnos en **jardines de infancia** y en los **primeros tres grados**, en clases pequeñas de **13 a 17 alumnos**, clases regulares de **22 a 25 alumnos** y clases regulares con un **profesor particular**. Aproximadamente 6500 alumnos en 330 aulas de unas 80 escuelas fueron evaluados en **lectura**, **matemáticas** y habilidades básicas de estudio mediante [pruebas estandarizadas](https://en.wikipedia.org/wiki/Stanford_Achievement_Test_Series). Después de los cuatro años, se comprobó que las clases pequeñas mejoraron significativamente el aprendizaje temprano y los estudios cognitivos.

```{r, groupsSTAR}
groupsTable <- data.frame(
  Grado = c("K", "1", "2", "3"),
  `Tratamiento 1` = c("Clase pequeña", "Clase pequeña", "Clase pequeña", "Clase pequeña"),
  `Tratamiento 2` = c("Clase regular + asistente", "Clase regular + asistente", "Clase regular + asistente", "Clase regular + asistente"),
  Control = c("Clase regular", "Clase regular", "Clase regular", "Clase regular")
)
kable(groupsTable, caption = "<strong>Tabla 1. </strong> Grupos de control y tratamiento en el experimento STAR")
```

Los datos del estudio están disponibles en el paquete `AER` de `R`.

## Descripción del problema

En primer lugar, cargamos los datos a nuestro espacio de trabajo.

```{r cargar-datos}
#| echo: true
data(STAR)
starDf <- STAR
```

Encontramos con las siguientes características:

1. **gender**: Factor que indica el género del estudiante.

2. **ethnicity**: Factor que indica la etnicidad del estudiante con niveles "cauc" (Caucásico), "afam" (Afroamericano), "asian" (Asiático), "hispanic" (Hispano), "amindian" (Indio Americano) o "other" (Otro).

3. **birth**: Trimestre de nacimiento del estudiante (del año de clase).

4. **stark**: Factor que indica el tipo de clase STAR en jardín de infancia: regular, pequeña o regular-con-ayudante. NA indica que no asistió a ninguna clase STAR.

5. **star1**: Factor que indica el tipo de clase STAR en primer grado: regular, pequeña o regular-con-ayudante. NA indica que no asistió a ninguna clase STAR.

6. **star2**: Factor que indica el tipo de clase STAR en segundo grado: regular, pequeña o regular-con-ayudante. NA indica que no asistió a ninguna clase STAR.

7. **star3**: Factor que indica el tipo de clase STAR en tercer grado: regular, pequeña o regular-con-ayudante. NA indica que no asistió a ninguna clase STAR.

8. **readk**: Puntuación total de lectura en jardín de infancia.

9. **read1**: Puntuación total de lectura en primer grado.

10. **read2**: Puntuación total de lectura en segundo grado.

11. **read3**: Puntuación total de lectura en tercer grado.

12. **mathk**: Puntuación total de matemáticas en jardín de infancia.

13. **math1**: Puntuación total de matemáticas en primer grado.

14. **math2**: Puntuación total de matemáticas en segundo grado.

15. **math3**: Puntuación total de matemáticas en tercer grado.

16. **lunchk**: Factor que indica si el estudiante calificó para almuerzo gratuito en jardín de infancia.

17. **lunch1**: Factor que indica si el estudiante calificó para almuerzo gratuito en primer grado.

18. **lunch2**: Factor que indica si el estudiante calificó para almuerzo gratuito en segundo grado.

19. **lunch3**: Factor que indica si el estudiante calificó para almuerzo gratuito en tercer grado.

20. **schoolk**: Factor que indica el tipo de escuela en jardín de infancia: "inner-city" (ciudad interior), "suburban" (suburbana), "rural" (rural) o "urban" (urbana).

21. **school1**: Factor que indica el tipo de escuela en primer grado: "inner-city" (ciudad interior), "suburban" (suburbana), "rural" (rural) o "urban" (urbana).

22. **school2**: Factor que indica el tipo de escuela en segundo grado: "inner-city" (ciudad interior), "suburban" (suburbana), "rural" (rural) o "urban" (urbana).

23. **school3**: Factor que indica el tipo de escuela en tercer grado: "inner-city" (ciudad interior), "suburban" (suburbana), "rural" (rural) o "urban" (urbana).

24. **degreek**: Factor que indica el título más alto del maestro en jardín de infancia: "bachelor" (licenciatura), "master" (maestría), "specialist" (especialista) o "master+" (maestría+).

25. **degree1**: Factor que indica el título más alto del maestro en primer grado: "bachelor" (licenciatura), "master" (maestría), "specialist" (especialista) o "phd" (doctorado).

26. **degree2**: Factor que indica el título más alto del maestro en segundo grado: "bachelor" (licenciatura), "master" (maestría), "specialist" (especialista) o "phd" (doctorado).

27. **degree3**: Factor que indica el título más alto del maestro en tercer grado: "bachelor" (licenciatura), "master" (maestría), "specialist" (especialista) o "phd" (doctorado).

28. **ladderk**: Factor que indica el nivel de carrera del maestro en jardín de infancia: "level1" (nivel 1), "level2" (nivel 2), "level3" (nivel 3), "apprentice" (aprendiz), "probation" (en prueba) o "pending" (pendiente).

29. **ladder1**: Factor que indica el nivel de carrera del maestro en primer grado: "level1" (nivel 1), "level2" (nivel 2), "level3" (nivel 3), "apprentice" (aprendiz), "probation" (en prueba) o "noladder" (sin nivel).

30. **ladder2**: Factor que indica el nivel de carrera del maestro en segundo grado: "level1" (nivel 1), "level2" (nivel 2), "level3" (nivel 3), "apprentice" (aprendiz), "probation" (en prueba) o "noladder" (sin nivel).

31. **ladder3**: Factor que indica el nivel de carrera del maestro en tercer grado: "level1" (nivel 1), "level2" (nivel 2), "level3" (nivel 3), "apprentice" (aprendiz), "probation" (en prueba) o "noladder" (sin nivel).

32. **experiencek**: Años de experiencia total del maestro en jardín de infancia.

33. **experience1**: Años de experiencia total del maestro en primer grado.

34. **experience2**: Años de experiencia total del maestro en segundo grado.

35. **experience3**: Años de experiencia total del maestro en tercer grado.

36. **tethnicityk**: Factor que indica la etnicidad del maestro en jardín de infancia con niveles "cauc" (Caucásico) o "afam" (Afroamericano).

37. **tethnicity1**: Factor que indica la etnicidad del maestro en primer grado con niveles "cauc" (Caucásico) o "afam" (Afroamericano).

38. **tethnicity2**: Factor que indica la etnicidad del maestro en segundo grado con niveles "cauc" (Caucásico) o "afam" (Afroamericano).

39. **tethnicity3**: Factor que indica la etnicidad del maestro en tercer grado con niveles "cauc" (Caucásico), "afam" (Afroamericano) o "asian" (Asiático).

40. **systemk**: Factor que indica el ID del sistema escolar en jardín de infancia.

41. **system1**: Factor que indica el ID del sistema escolar en primer grado.

42. **system2**: Factor que indica el ID del sistema escolar en segundo grado.

43. **system3**: Factor que indica el ID del sistema escolar en tercer grado.

44. **schoolidk**: Factor que indica el ID de la escuela en jardín de infancia.

45. **schoolid1**: Factor que indica el ID de la escuela en primer grado.

46. **schoolid2**: Factor que indica el ID de la escuela en segundo grado.

47. **schoolid3**: Factor que indica el ID de la escuela en tercer grado.

### Análisis exploratorio de datos

Observamos que hay una gran cantidad de datos faltantes en la mayor parte de las variables.

```{r aed-na, fig.cap=capFig("Porcentaje de valores faltantes en las variables del conjunto de datos.", y = "aed-na")}
na_counts <- sapply(starDf, function(x) sum(is.na(x)))
total_counts <- nrow(starDf)

na_percentage <- (na_counts / total_counts) * 100

na_percentage_df <- data.frame(
  Column = names(na_percentage),
  NA_Percentage = as.numeric(na_percentage)
)

ggplot(na_percentage_df, aes(x = Column, y = NA_Percentage)) +
  geom_bar(stat = "identity") +
  labs(x = "Característica",
       y = "Porcentaje de NA (%)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::percent_format(scale = 1))
```

Esto se debe a la naturaleza de los datos: por ejemplo, consideremos la primera observación.

```{r aed-na-ejemplo}
starDf[1, ]
```

En la salida encontramos que el estudiante ingresó al experimento en tercer grado en una clase regular, por lo que el tamaño de la clase se registra en star3 y las otras variables indicadoras de tipo de clase son `NA`. De la misma manera, sus puntuaciones de matemáticas y lectura para el tercer grado están disponibles; sin embargo, los valores de estas variables para otros grados no están presentes por la misma razón.

A modo de comprobación, nos aseguramos todas las entradas corresponden a estudiantes que participaron en el proyecto *STAR* al menos durante uno de los cuatro años.

```{r}
nAllStarsNA <- sum(rowSums(is.na(starDf[, c("stark", "star1", "star2", "star3")])) == 4)
cat("Número de entradas sin participaciones:", nAllStarsNA)
```

A continuación, analizamos las distribuciones de las variables descritas.

```{r aed-genero, fig.cap=capFig("Diagrama de barras del género de los estudiantes.", y = "aed-genero")}
ggplot(starDf, aes(x = gender)) +
  geom_bar() +
  labs(x = "Género", y = "Frecuencia acumulada")
```


```{r aed-etnicidad, fig.cap=capFig("Diagrama de barras de la etnicidad de los estudiantes.", y = "aed-etnicidad")}
ggplot(starDf, aes(x = ethnicity)) +
  geom_bar() +
  labs(x = "Etnicidad", y = "Frecuencia acumulada")
```


```{r aed-trim-nac, fig.cap=capFig("Diagrama de barras del trimestre de nacimiento de los estudiantes.", y = "aed-trim-nac")}
ggplot(starDf, aes(x = birth)) +
  geom_bar() +
  labs(x = "Trimestre de nacimiento", y = "Frecuencia acumulada")
```

```{r aed-grupo, fig.cap=capFig("Diagrama de barras del grupo experimental de todos los cursos.", y = "aed-grupo")}
plotCombinedFeature(starDf, "star", "Grupo experimental", isNumeric = FALSE)
```

```{r aed-lectura, fig.cap=capFig("Boxplot de la puntuación de lectura de todos los cursos.", y = "aed-lectura")}
plotCombinedFeature(starDf, "read", "Puntuación de lectura")
```


```{r aed-mate, fig.cap=capFig("Boxplot de la puntuación de matemáticas de todos los cursos.", y = "aed-mate")}
plotCombinedFeature(starDf, "math", "Puntuación de matemáticas")
```


```{r aed-almuerzo, fig.cap=capFig("Diagrama de barras de la participación en el almuerzo gratuito de todos los cursos.", y = "aed-almuerzo")}
plotCombinedFeature(starDf, "lunch", "Almuerzo", isNumeric = FALSE)
```

```{r aed-tipo-escuela, fig.cap=capFig("Diagrama de barras del tipo de escuela de todos los cursos.", y = "aed-tipo-escuela")}
plotCombinedFeature(starDf, "school", "Tipo de escuela", isNumeric = FALSE)
```

```{r aed-titulo-maestro, fig.cap=capFig("Diagrama de barras del máximo título académico del maestro de todos los cursos.", y = "aed-titulo-maestro")}
plotCombinedFeature(starDf, "degree", "Título académico", isNumeric = FALSE)
```

```{r aed-nivel-carrera, fig.cap=capFig("Diagrama de barras del nivel de carrera del maestro de todos los cursos.", y = "aed-nivel-carrera")}
plotCombinedFeature(starDf, "ladder", "Nivel de carrera", isNumeric = FALSE)
```

```{r aed-exp, fig.cap=capFig("Boxplot de la experiencia del maestro de todos los cursos.", y = "aed-exp")}
plotCombinedFeature(starDf, "experience", "Experiencia del maestro (años)")
```

```{r aed-etnicidad-maestro, fig.cap=capFig("Diagrama de barras de la etnicidad del maestro de todos los cursos.", y = "aed-etnicidad-maestro")}
plotCombinedFeature(starDf, "tethnicity", "Etnicidad del maestro", isNumeric = FALSE)
```

```{r aed-id-escuela, fig.cap=capFig("Diagrama de barras de la etnicidad del maestro de todos los cursos.", y = "aed-id-escuela")}
plotCombinedFeature(starDf, "schoolid", "Identificador de escuela", isNumeric = FALSE, removeNa = TRUE)
```

### Identificación de efecto y tratamiento

En el proyecto *STAR*, el tratamiento aplicado es la pertenencia a clases reducidas y a clases normales con ayuda, frente a clases normales sin ayuda. En este trabajo, convertimos este tratamiento en dos tratamientos binarios:

- Clase reducida frente a clase normal
- Clase normal con ayuda frente a clase normal sin ayuda

Por otra parte, escogemos como efecto la variación de una nueva variable **nota**, definida como la suma de las puntuaciones en lectura y matemáticas, habitual en la literatura relacionada con este estudio.

Además, realizamos el análisis para cada año de manera independiente.

```{r}
nota <- data.frame(
  # Kindergarten
  notak <- starDf$readk + starDf$mathk,
  # 1st Grade
  nota1 <- starDf$read1 + starDf$math1,
  # 2nd Grade
  nota2 <- starDf$read2 + starDf$math2,
  # 3rd Grade
  nota3 <- starDf$read3 + starDf$math3
)

# Eliminar los registros con NA en cualquier variable 'nota'
nota <- nota[complete.cases(nota), ]
```


```{r}
plot(x)

nota1_per <- round((nota1 - min(nota1, na.rm = TRUE)) / (max(nota1, na.rm = TRUE) - min(nota1, na.rm = TRUE)) * 100, 0)
x <- density(nota1_per, na.rm = TRUE)

plot(x)

nota2_per <- round((nota2 - min(nota2, na.rm = TRUE)) / (max(nota2, na.rm = TRUE) - min(nota2, na.rm = TRUE)) * 100, 0)
x <- density(nota2_per, na.rm = TRUE)

plot(x)

nota3_per <- round((nota3 - min(nota3, na.rm = TRUE)) / (max(nota3, na.rm = TRUE) - min(nota3, na.rm = TRUE)) * 100, 0)
x <- density(nota3_per, na.rm = TRUE)

plot(x)

```
```{r}
# Función para convertir datos a índices de cuartiles
convertir_a_cuartiles <- function(datos) {
  cuartiles <- quantile(datos, probs = seq(0, 1, by = 0.01), na.rm = TRUE)
  cuartiles <- unique(cuartiles)

# Si hay menos de 5 límites únicos, añadir una pequeña cantidad para hacerlos únicos
if (length(cuartiles) < 5) {
  cuartiles <- sort(unique(c(cuartiles, cuartiles + 1e-10 * (1:length(cuartiles)))))
}
  as.numeric(cut(datos, breaks = cuartiles, include.lowest = TRUE))
}

# Crear un vector de ejemplo

# Convertir los datos a índices de cuartiles
notak_per <- convertir_a_cuartiles(notak)
x <- density(notak_per, na.rm = TRUE)

plot(x)

nota1_per <- convertir_a_cuartiles(nota1)
x <- density(nota1_per, na.rm = TRUE)

plot(x)

nota2_per <- convertir_a_cuartiles(nota2)
x <- density(nota2_per, na.rm = TRUE)

plot(x)

nota3_per <- convertir_a_cuartiles(nota3)
x <- density(nota3_per, na.rm = TRUE)

plot(x)

starDf <-  starDf |> mutate(notak_per,nota1_per,nota2_per,nota3_per)
```

```{r}
#Df para kindergarten
StarkDf <- data.frame(
  stark <- starDf$stark,
  notak <- notak_per,
  lunchk <- starDf$lunchk,
  schoolk <- starDf$schoolk,
  degreek <- starDf$degreek,
  ladderk <- starDf$ladderk,
  experiencek <- starDf$experiencek,
  tethnicityk <- starDf$tethnicityk,
  systemk <- starDf$systemk,
  schoolidk <- starDf$schoolidk,
  genderk <- starDf$gender,
  ethnicityk <- starDf$ethnicity,
  birthk <- starDf$birth
)

names(StarkDf) <- c(
  "stark","notak", "lunchk", "schoolk", "degreek", "ladderk", "experiencek",
  "tethnicityk", "systemk", "schoolidk", "genderk", "ethnicityk",
  "birthk"
)

#Df para grade 1
Star1Df <- data.frame(
  star1 <- starDf$star1,
  nota1 <- nota1_per,
  lunch1 <- starDf$lunch1,
  school1 <- starDf$school1,
  degree1 <- starDf$degree1,
  ladder1 <- starDf$ladder1,
  experience1 <- starDf$experience1,
  tethnicity1 <- starDf$tethnicity1,
  system1 <- starDf$system1,
  schoolid1 <- starDf$schoolid1,
  gender1 <- starDf$gender,
  ethnicity1 <- starDf$ethnicity,
  birth1 <- starDf$birth
)

names(Star1Df) <- c(
  "star1","nota1", "lunch1", "school1", "degree1", "ladder1", "experience1",
  "tethnicity1", "system1", "schoolid1", "gender1", "ethnicity1",
  "birth1"
)

#Df para grade 2
Star2Df <- data.frame(
  star2 <- starDf$star2,
  nota2 <- nota2_per,
  lunch2 <- starDf$lunch2,
  school2 <- starDf$school2,
  degree2 <- starDf$degree2,
  ladder2 <- starDf$ladder2,
  experience2 <- starDf$experience2,
  tethnicity2 <- starDf$tethnicity2,
  system2 <- starDf$system2,
  schoolid2 <- starDf$schoolid2,
  gender2 <- starDf$gender,
  ethnicity2 <- starDf$ethnicity,
  birth2 <- starDf$birth
)

names(Star2Df) <- c(
  "star2","nota2", "lunch2", "school2", "degree2", "ladder2", "experience2",
  "tethnicity2", "system2", "schoolid2", "gender2", "ethnicity2",
  "birth2"
)

#Df para grade 3
Star3Df <- data.frame(
  star3 <- starDf$star3,
  nota3 <- nota3_per,
  lunch3 <- starDf$lunch3,
  school3 <- starDf$school3,
  degree3 <- starDf$degree3,
  ladder3 <- starDf$ladder3,
  experience3 <- starDf$experience3,
  tethnicity3 <- starDf$tethnicity3,
  system3 <- starDf$system3,
  schoolid3 <- starDf$schoolid3,
  gender3 <- starDf$gender,
  ethnicity3 <- starDf$ethnicity,
  birth3 <- starDf$birth
)
names(Star3Df) <- c(
  "star3","nota3", "lunch3", "school3", "degree3", "ladder3", "experience3",
  "tethnicity3", "system3", "schoolid3", "gender3", "ethnicity3",
  "birth3"
)

```


```{r}
# Realizar One-hot encoding de todas las variables categóricas
StarkDf_encoded <- dummy_cols(StarkDf, select_columns = c(
  "lunchk", "schoolk", "degreek", "ladderk", 
  "tethnicityk", "genderk", "ethnicityk"
))

Star1Df_encoded <- dummy_cols(Star1Df, select_columns = c(
  "lunch1", "school1", "degree1", "ladder1", 
  "tethnicity1", "gender1", "ethnicity1"
))

Star2Df_encoded <- dummy_cols(Star2Df, select_columns = c(
  "lunch2", "school2", "degree2", "ladder2", 
  "tethnicity2", "gender2", "ethnicity2"
))

Star3Df_encoded <- dummy_cols(Star3Df, select_columns = c(
  "lunch3", "school3", "degree3", "ladder3", 
  "tethnicity3", "gender3", "ethnicity3"
))
```

Eliminar columnas no numéricas

```{r}
StarkDf_encoded <- dummy_cols(StarkDf, select_columns = c(
  "lunchk", "schoolk", "degreek", "ladderk", 
  "tethnicityk", "genderk", "ethnicityk"
))

Star1Df_encoded <- dummy_cols(Star1Df, select_columns = c(
  "lunch1", "school1", "degree1", "ladder1", 
  "tethnicity1", "gender1", "ethnicity1"
))

Star2Df_encoded <- dummy_cols(Star2Df, select_columns = c(
  "lunch2", "school2", "degree2", "ladder2", 
  "tethnicity2", "gender2", "ethnicity2"
))

Star3Df_encoded <- dummy_cols(Star3Df, select_columns = c(
  "lunch3", "school3", "degree3", "ladder3", 
  "tethnicity3", "gender3", "ethnicity3"
))
```


```{r}
StarkDf_encoded_grouped <- StarkDf_encoded %>%
  mutate(across(.cols = c(systemk, schoolidk), .fns = as.numeric)) %>%
  group_by(stark) %>%
  select(-c(lunchk, schoolk, degreek, ladderk, tethnicityk, genderk, ethnicityk, birthk))%>%
  summarise_all(mean)

Star1Df_encoded_grouped <- Star1Df_encoded %>%
  mutate(across(.cols = c(system1, schoolid1), .fns = as.numeric)) %>%
  group_by(star1) %>%
  select(-c(lunch1, school1, degree1, ladder1, tethnicity1, gender1, ethnicity1, birth1))%>%
  summarise_all(mean)

Star2Df_encoded_grouped <- Star2Df_encoded %>%
  mutate(across(.cols = c(system2, schoolid2), .fns = as.numeric)) %>%
  group_by(star2) %>%
  select(-c(lunch2, school2, degree2, ladder2, tethnicity2, gender2, ethnicity2, birth2))%>%
  summarise_all(mean)

Star3Df_encoded_grouped <- Star3Df_encoded %>%
  mutate(across(.cols = c(system3, schoolid3), .fns = as.numeric)) %>%
  group_by(star3) %>%
  select(-c(lunch3, school3, degree3, ladder3, tethnicity3, gender3, ethnicity3, birth3))%>%
  summarise_all(mean)
```

```{r}
StarkDf_encoded_w_a <- StarkDf_encoded %>% filter(stark != "regular+aide") %>% mutate(stark = ifelse(stark == "small", 1, 0))
Star1Df_encoded_w_a <- Star1Df_encoded %>% filter(star1 != "regular+aide") %>% mutate(star1 = ifelse(star1 == "small", 1, 0))
Star2Df_encoded_w_a <- Star2Df_encoded %>% filter(star2 != "regular+aide") %>% mutate(star2 = ifelse(star2 == "small", 1, 0))
Star3Df_encoded_w_a <- Star3Df_encoded %>% filter(star3 != "regular+aide") %>% mutate(star3 = ifelse(star3 == "small", 1, 0))
```

```{r}
StarkDf_encoded_w_a <- StarkDf_encoded_w_a[complete.cases(StarkDf_encoded_w_a), ]
Star1Df_encoded_w_a <- Star1Df_encoded_w_a[complete.cases(Star1Df_encoded_w_a), ]
Star2Df_encoded_w_a <- Star2Df_encoded_w_a[complete.cases(Star2Df_encoded_w_a), ]
Star3Df_encoded_w_a <- Star3Df_encoded_w_a[complete.cases(Star3Df_encoded_w_a), ]
```


```{r}
#small_k <- starDf |> select(stark,notak_per) |>  filter(stark == 'small') |> 
#reg_k <- starDf |> select(stark,notak_per) |>  filter(stark != 'small')

#x <- density(small_k$notak_per, na.rm = TRUE)
#y <- density(reg_k$notak_per, na.rm = TRUE)

```


```{r}
first_lm <- lm(notak_per ~ stark,data = starDf)
summary(first_lm)
second_lm <- lm(nota1_per ~ star1,data = starDf)
summary(second_lm)
third_lm <- lm(nota2_per ~ star2,data = starDf)
summary(third_lm)
fourth_lm <- lm(nota3_per ~ star3 ,data = starDf)
summary(fourth_lm)
```

```{r}
starDf|> select(ethnicity,school1,school2,school3,schoolk)|> filter(schoolk == 'rural') |> count(ethnicity)
```

```{r}
starDf|> select(ethnicity,school1,school2,school3,schoolk,stark,star1,star2,star3)|> filter(stark == "small") |> count(schoolk)
```

# EFECTOS HETEROGENEOS

```{r}
library(reticulate)
use_condaenv('inferencia')
rpy2py <- r_to_py(StarkDf_encoded_w_a)
```

```{python}
from doubleml import DoubleMLData
```

```{python}
import pandas as pd
import numpy as np

# Create a pandas DataFrame from the R data frame
rpy2py_df = pd.DataFrame(r.rpy2py)


# # Perform one-hot encoding on the categorical variable 'ethnicity'
# rpy2py_df_encoded = pd.get_dummies(rpy2py_df, columns=['ethnicity'], drop_first=True)
# 
# # Convert boolean columns to integers
# boolean_columns = rpy2py_df_encoded.select_dtypes(include='bool').columns
# rpy2py_df_encoded[boolean_columns] = rpy2py_df_encoded[boolean_columns].astype(int)
# 
# dummies = []
# rpy2py_df_encoded.iloc[:,50:55]
# for i in range(50,55):
#   ls = list(rpy2py_df_encoded.iloc[:,i:i+1])
#   dummies.append(ls)
# dummies
# Define the DoubleMLData object
dml_data = DoubleMLData(rpy2py_df,
                        y_col='notak',
                        d_cols='stark',
                        x_cols=None)
```

```{python}
dml_data
```


```{python}
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor

ml_m_rf = RandomForestRegressor()  # media condicional de la respuesta
ml_e_rf = RandomForestClassifier() # propensity score 

from xgboost import XGBClassifier, XGBRegressor

ml_m_xgb = XGBRegressor(objective = "reg:squarederror")


ml_e_xgb = XGBClassifier(use_label_encoder = False ,
                         objective = "binary:logistic",
                         eval_metric = "logloss")
```

```{python}
from doubleml import DoubleMLPLR
```

```{python}

np.random.seed(123)
dml_plr_forest = DoubleMLPLR(dml_data,
                             ml_l = ml_m_rf, # modelo ML para media condicional de respuesta
                             ml_m = ml_e_rf, # modelo ML para propensity score
                             n_folds = 10)

```

```{python}
dml_plr_xgb = DoubleMLPLR(dml_data,
                             ml_l = ml_m_xgb,
                             ml_m = ml_e_xgb,
                             n_folds = 10)
```

```{python}
dml_plr_forest.fit()
dml_plr_xgb.fit()
```


This is where the estimation takes place. Note that referring to R objects while in Python is done using the `r.` prefix. For example, `r.Y` returns R's `Y` object in Python.
```{python}

est = DMLCateEstimator(model_y=MultiTaskElasticNetCV(cv=3),model_t=MultiTaskElasticNetCV(cv=3))

est.fit(r.notak_per, r.D, r.X, r.W)

te_pred = est.const_marginal_effect(r.X_test)

```
```

